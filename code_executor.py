"""Safe code executor for search agent programs.

This module provides a secure execution environment for running Python code
generated by the search agent. It enforces safety through AST validation and
restricted execution context.
"""

import ast
import json
import re
import sys
import traceback
from typing import Any
from concurrent.futures import ThreadPoolExecutor, TimeoutError as FuturesTimeoutError

from langchain_core.tools import StructuredTool

from tools import (
    web_search,
    web_read,
    get_current_time,
    init_search_session,
    set_search_task,
    record_search_result,
    add_collected_info,
    get_search_status,
    get_search_history,
    reflect_on_coverage,
    evaluate_search_quality,
    should_continue_searching,
    get_collected_summary,
)


# Dangerous functions/attributes that should be blocked
BLOCKED_NAMES = {
    # Code execution
    'eval', 'exec', 'compile', '__import__',
    # System access
    'open', 'input', 'breakpoint', 'exit', 'quit',
    # Unsafe builtins
    'globals', 'locals', 'vars', 'dir',
    # Module introspection
    '__builtins__', '__name__', '__doc__', '__package__',
    '__loader__', '__spec__', '__annotations__', '__builtins__',
    '__file__', '__cached__',
    # OS/system access
    'system', 'popen', 'spawn', 'fork', 'execve', 'execl',
    # File operations
    'remove', 'rename', 'rmdir', 'mkdir', 'makedirs', 'chmod',
    # Network
    'socket', 'connect',
}


class CodeValidationError(Exception):
    """Raised when code fails validation."""
    pass


class CodeExecutionError(Exception):
    """Raised when code execution fails."""
    pass


class SearchCodeExecutor:
    """Safe search code executor with AST validation.

    This executor validates and runs Python code in a restricted environment
    that only has access to search-related tools.
    """

    def __init__(self):
        """Initialize the executor with search tools context."""
        self._context = {
            # Search tools
            'web_search': web_search,
            'web_read': web_read,
            # Time utility
            'get_current_time': get_current_time,
            # Search state management
            'init_search_session': init_search_session,
            'set_search_task': set_search_task,
            'record_search_result': record_search_result,
            'add_collected_info': add_collected_info,
            'get_search_status': get_search_status,
            'get_search_history': get_search_history,
            # Reflection tools
            'reflect_on_coverage': reflect_on_coverage,
            'evaluate_search_quality': evaluate_search_quality,
            'should_continue_searching': should_continue_searching,
            'get_collected_summary': get_collected_summary,
            # Safe builtins
            'print': print,
            'len': len,
            'range': range,
            'enumerate': enumerate,
            'zip': zip,
            'list': list,
            'dict': dict,
            'str': str,
            'int': int,
            'float': float,
            'bool': bool,
            'tuple': tuple,
            'set': set,
            'sorted': sorted,
            'reversed': reversed,
            'min': min,
            'max': max,
            'sum': sum,
            'any': any,
            'all': all,
            'abs': abs,
            'round': round,
            'isinstance': isinstance,
            'type': type,
            'True': True,
            'False': False,
            'None': None,
            # Modules
            'json': json,
            're': re,
        }

    def validate_code(self, code: str) -> tuple[bool, str]:
        """Validate code for safety using AST analysis.

        Args:
            code: Python code string to validate

        Returns:
            Tuple of (is_valid, error_message)
        """
        if not code or not isinstance(code, str):
            return False, "Code must be a non-empty string"

        # Parse the code
        try:
            tree = ast.parse(code)
        except SyntaxError as e:
            return False, f"Syntax error: {e}"

        # Check for dangerous constructs
        for node in ast.walk(tree):
            # Check function calls
            if isinstance(node, ast.Call):
                func_name = self._get_func_name(node.func)
                if func_name in BLOCKED_NAMES:
                    return False, f"Blocked function call: {func_name}"

            # Check attribute access
            if isinstance(node, ast.Attribute):
                if node.attr in BLOCKED_NAMES:
                    return False, f"Blocked attribute access: {node.attr}"

            # Check name references
            if isinstance(node, ast.Name):
                if node.id in BLOCKED_NAMES:
                    return False, f"Blocked name reference: {node.id}"

            # Check imports
            if isinstance(node, (ast.Import, ast.ImportFrom)):
                return False, "Import statements are not allowed"

            # Check class definitions (could be used for metaclass tricks)
            if isinstance(node, ast.ClassDef):
                return False, "Class definitions are not allowed"

            # Check for __dunder__ access
            if isinstance(node, ast.Attribute):
                if node.attr.startswith('__') and node.attr.endswith('__'):
                    # Allow some safe dunders
                    safe_dunders = {'__name__', '__doc__'}
                    if node.attr not in safe_dunders:
                        return False, f"Access to {node.attr} is not allowed"

        return True, ""

    def _get_func_name(self, node) -> str:
        """Extract function name from AST node."""
        if isinstance(node, ast.Name):
            return node.id
        elif isinstance(node, ast.Attribute):
            return node.attr
        return ""

    def execute(self, code: str, timeout: int = 120) -> dict[str, Any]:
        """Execute the validated code in a restricted environment.

        Args:
            code: Python code string to execute
            timeout: Maximum execution time in seconds (default 120)

        Returns:
            Dict with keys:
                - success: bool indicating if execution succeeded
                - output: captured stdout output
                - result: value of 'result' variable if set
                - error: error message if execution failed
                - execution_time: time taken in seconds
        """
        import time
        start_time = time.time()

        # Validate code first
        is_valid, error_msg = self.validate_code(code)
        if not is_valid:
            return {
                "success": False,
                "output": "",
                "result": None,
                "error": f"Validation error: {error_msg}",
                "execution_time": time.time() - start_time
            }

        # Capture stdout
        from io import StringIO
        old_stdout = sys.stdout
        captured_output = StringIO()
        sys.stdout = captured_output

        # Prepare execution namespace
        exec_globals = self._context.copy()
        exec_locals = {}

        def run_code():
            exec(code, exec_globals, exec_locals)

        try:
            # Execute with timeout
            with ThreadPoolExecutor(max_workers=1) as executor:
                future = executor.submit(run_code)
                future.result(timeout=timeout)

            execution_time = time.time() - start_time

            # Get result if set
            result = exec_locals.get('result', None)

            return {
                "success": True,
                "output": captured_output.getvalue(),
                "result": result,
                "error": None,
                "execution_time": execution_time,
                "variables": {
                    k: str(v)[:500]  # Truncate long values
                    for k, v in exec_locals.items()
                    if not k.startswith('_') and k != 'result'
                }
            }

        except FuturesTimeoutError:
            return {
                "success": False,
                "output": captured_output.getvalue(),
                "result": None,
                "error": f"Execution timed out after {timeout} seconds",
                "execution_time": timeout
            }

        except Exception as e:
            return {
                "success": False,
                "output": captured_output.getvalue(),
                "result": None,
                "error": f"{type(e).__name__}: {str(e)}\n{traceback.format_exc()}",
                "execution_time": time.time() - start_time
            }

        finally:
            sys.stdout = old_stdout


def execute_search_code(code: str, timeout: int = 120) -> dict[str, Any]:
    """Execute a search program code string.

    This is the main tool function that the agent calls to run generated code.

    Args:
        code: Complete Python program code to execute. The code should:
              1. Start by calling get_current_time() to check current time
              2. Initialize search session with init_search_session()
              3. Set task with set_search_task()
              4. Perform searches with web_search()
              5. Collect and reflect on results
              6. Optionally set a 'result' variable for return value

        timeout: Maximum execution time in seconds (default 120, max 300)

    Returns:
        Dict containing:
        - success: Whether execution completed without errors
        - output: All print() output from the code
        - result: The value of 'result' variable if set in code
        - error: Error message if execution failed
        - execution_time: Time taken to execute

    Example code:
        ```python
        # Get current time first
        t = get_current_time()
        print(f"Search started: {t['message']}")

        # Initialize session
        init_search_session(max_search_rounds=5)
        set_search_task(
            task="Research AI trends",
            required_info_types=["news", "analysis"],
            min_sources=3
        )

        # Search loop
        while True:
            results = web_search(query="AI trends 2025", freshness="oneMonth")
            # Process results...

            decision = should_continue_searching(task_complete=False)
            if not decision['should_continue']:
                break

        result = get_collected_summary()
        ```
    """
    # Enforce max timeout
    timeout = min(timeout, 300)

    executor = SearchCodeExecutor()
    return executor.execute(code, timeout)


def create_execute_search_code_tool() -> StructuredTool:
    """Create a StructuredTool for the execute_search_code function.

    Returns:
        A LangChain StructuredTool that wraps execute_search_code
    """
    return StructuredTool.from_function(
        func=execute_search_code,
        name="execute_search_code",
        description="""Execute a complete Python search program.

        Use this tool to run a full search program that you generate. The program
        should contain all the logic needed to complete the research task, including:
        - Time checking
        - Search session initialization
        - Multiple search queries
        - Result processing and reflection
        - Loop control with should_continue_searching()

        The code will be executed in a safe environment with access to all search tools.
        """,
        args_schema=None,  # Let it infer from function signature
    )


__all__ = [
    "SearchCodeExecutor",
    "execute_search_code",
    "create_execute_search_code_tool",
    "CodeValidationError",
    "CodeExecutionError",
]
